# RSA - Level 4

# See the attachment for the challenge code. The output is:
# 136372941954692995052032614106416002216650352281441768759106047115825257661310123118558086046873251952204915740853517008372422353621244931366409094731856824295828106036399145756514345255241109944294641060644246049854296519101775880563276657142059245230769447888021843340822736997057074223723734593369646608283
# [88934261481985787316571946676203348514352494646042103159736155624287938096099586834729171652139440814472420307071476143907698982272593448957770236088603490101924827608944006107576740571416087954304061091614594794358854353419664581332745351113861171522629631586344259719016707622211007808872462656489173218734, 31191490339291402076171068036548032381977184741778243810947202097002026583133103229115040414216968980627919985794378128894603186334221963211692252394535977554990491215621733091487550326776298499502932523408287882489799200954692353162958794137970552454035789701538315132727860436887544051794011893682559545564]

"""
Solve RSA CTF with same modulus and two exponents via the common modulus attack:

Given:
  n = 136372941954692995052032614106416002216650352281441768759106047115825257661310123118558086046873251952204915740853517008372422353621244931366409094731856824295828106036399145756514345255241109944294641060644246049854296519101775880563276657142059245230769447888021843340822736997057074223723734593369646608283
  ciphers = [c1, c2]
  exponents = [e1, e2]

Since gcd(e1, e2) = 1, find integers a, b such that a*e1 + b*e2 = 1 via Extended GCD.
Then the plaintext m = c1^a * c2^b mod n (handling negative exponents via modular inverses).
Finally, convert m back to bytes to recover the flag.
"""

import math
from Crypto.Util.number import long_to_bytes, inverse

# Challenge values
n = 136372941954692995052032614106416002216650352281441768759106047115825257661310123118558086046873251952204915740853517008372422353621244931366409094731856824295828106036399145756514345255241109944294641060644246049854296519101775880563276657142059245230769447888021843340822736997057074223723734593369646608283
c1 = 88934261481985787316571946676203348514352494646042103159736155624287938096099586834729171652139440814472420307071476143907698982272593448957770236088603490101924827608944006107576740571416087954304061091614594794358854353419664581332745351113861171522629631586344259719016707622211007808872462656489173218734
c2 = 31191490339291402076171068036548032381977184741778243810947202097002026583133103229115040414216968980627919985794378128894603186334221963211692252394535977554990491215621733091487550326776298499502932523408287882489799200954692353162958794137970552454035789701538315132727860436887544051794011893682559545564
e1, e2 = 31, 71

# Extended Euclidean Algorithm to find (g, x, y) such that x*a + y*b = g = gcd(a, b)
def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    else:
        g, x1, y1 = extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return (g, x, y)

def main():
    # Step 1: compute a, b with a*e1 + b*e2 = 1
    g, a, b = extended_gcd(e1, e2)
    if g != 1:
        raise ValueError(f"Exponents not coprime: gcd = {g}")

    # Step 2: compute c1^a mod n and c2^b mod n, handling negative exponents
    if a < 0:
        c1_part = pow(inverse(c1, n), -a, n)
    else:
        c1_part = pow(c1, a, n)
    if b < 0:
        c2_part = pow(inverse(c2, n), -b, n)
    else:
        c2_part = pow(c2, b, n)

    # Step 3: combine to get plaintext m
    m = (c1_part * c2_part) % n

    # Step 4: convert integer m back to bytes
    flag = long_to_bytes(m)
    print(flag.decode())

if __name__ == '__main__':
    main()
